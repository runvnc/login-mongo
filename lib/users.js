// Generated by ToffeeScript 1.6.3-5
(function() {
  var Mongolian, bcrypt, dash, db, fs, mustache, nodemailer, opts, randpass, server, smtp, transp, users,
    _this = this;

  bcrypt = require('bcrypt');

  randpass = require('randpass');

  fs = require('fs');

  nodemailer = require('nodemailer');

  Mongolian = require('mongolian');

  dash = require('lodash');

  mustache = require('mustache');

  function delay(ms, func) {
    return setTimeout(func, ms);
  };

  server = null;

  db = null;

  users = null;

  opts = {
    iterations: 10,
    mail: {
      from: 'root',
      subjectadd: 'User account created',
      bodyadd: "Username: {{name}}",
      bodyreset: "Username: {{name}}",
      subjectreset: 'Password reset',
      mailer: 'sendmail'
    },
    collection: 'users',
    sendEmails: true
  };

  transp = {
    sendmail: true,
    newline: 'unix',
    path: '/usr/sbin/sendmail'
  };

  smtp = nodemailer.createTransport(transp);

  function getMailer() {
    var _ref;
    if (((_ref = opts.mail) != null ? _ref.mailer : void 0) !== 'sendmail') {
      return opts.mail.mailer;
    } else {
      return smtp;
    }
  };

  function config(options) {
    dash.merge(opts, options);
    if (opts.connect != null) {
      db = new Mongolian(opts.connect);
    } else {
      db = new Mongolian('mongo://localhost:27017/users');
    }
    if (opts.collection != null) {
      return users = db.collection(opts.collection);
    } else {
      return users = db.collection('users');
    }
  };

  config({});

  function checkExists(email, cb) {
    var e, existing,
      _this = this;
    users.findOne({
      email: email
    }, function() {
      e = arguments[0], existing = arguments[1];
      return cb(existing != null);
    });
  };

  function addNoEmail(email, name, pass, cb) {
    var err, hash,
      _this = this;
    checkExists(email, function(_$$_2) {
      _$cb$_1(!_$$_2);
    });
    function _$cb$_1(_$$_0) {
      if (_$$_0) {
        bcrypt.hash(pass, opts.iterations, function() {
          err = arguments[0], hash = arguments[1];
          users.insert({
            email: email,
            name: name,
            passhash: hash
          }, function() {
            return typeof cb === "function" ? cb() : void 0;
          });
        });
      } else {
        return typeof cb === "function" ? cb() : void 0;
      }
    };
  };

  function add(email, name, pass, cb) {
    var e, e1, e2, err, existing, hash, mailer, newuser, options, rendered, val;
    checkExists(email, function() {
      existing = arguments[0];
      checkExists(email, function(_$$_7) {
        _$cb$_6(!_$$_7);
      });
      function _$cb$_6(_$$_4) {
        if (_$$_4) {
          try {
            bcrypt.hash(pass, opts.iterations, function() {
              err = arguments[0], hash = arguments[1];
              newuser = {
                email: email,
                name: name,
                passhash: hash
              };
              users.insert(newuser, function() {
                e2 = arguments[0], val = arguments[1];
                newuser.password = pass;
                try {
                  rendered = mustache.render(opts.mail.bodyadd, newuser);
                } catch (_error) {
                  e1 = _error;
                  return cb(new Error("Error rendering email body for new user mail: " + e1.message), false);
                }
                if (opts.sendEmails) {
                  try {
                    options = {
                      from: opts.mail.from,
                      to: email,
                      subject: opts.mail.subjectadd,
                      text: rendered
                    };
                    mailer = getMailer();
                    mailer.sendMail(options, function(err, res) {
                      if (err != null) {
                        return console.log(err);
                      } else {
                        return console.log('Message sent: ' + res.message);
                      }
                    });
                  } catch (_error) {
                    e = _error;
                    console.log('Error sending user mail' + e.message);
                    console.log(e);
                    return cb(new Error("Error sending user mail: " + e.message));
                  }
                }
                _$$_5(cb(null, true));
              });
            });
          } catch (_error) {
            e = _error;
            console.log('There was an error');
            console.log(e);
            return cb(new Error("Error creating user: " + e.message), false);
          }
        } else {
          cb(null, false);
          _$$_5();
        }
        function _$$_5() {
          return null;
        };
      };
    });
  };

  function resetPassword(name, cb) {
    var change, e, err, hash, mailer, options, pass, rendered, user;
    users.findOne({
      name: name
    }, function() {
      e = arguments[0], user = arguments[1];
      if (user != null) {
        pass = randpass();
        bcrypt.hash(pass, opts.iterations, function() {
          err = arguments[0], hash = arguments[1];
          change = {
            $set: {
              passhash: hash
            }
          };
          users.update({
            name: name
          }, change, function() {
            rendered = mustache.render(opts.mail.bodyreset, user);
            if (opts.sendEmails) {
              try {
                options = {
                  from: opts.mail.from,
                  to: user.email,
                  subject: opts.mail.subjectreset,
                  text: rendered
                };
                mailer = getMailer();
                mailer.sendMail(options, function(err, res) {
                  if (err != null) {
                    return console.log(err);
                  } else {
                    return console.log('Message sent: ' + res.message);
                  }
                });
              } catch (_error) {
                e = _error;
                console.log('Error sending user mail' + e.message);
                console.log(e);
              }
            }
            cb(pass);
            _$$_9();
          });
        });
      } else {
        _$$_9();
      }
      function _$$_9() {
        return null;
      };
    });
  };

  function updatePassword(username, oldpass, newpass, cb) {
    var change, err, hash;
    checkPassword(username, oldpass, function(_$$_12) {
      _$cb$_11(!_$$_12);
    });
    function _$cb$_11(_$$_10) {
      if (_$$_10) {
        return cb(false);
      } else {
        bcrypt.hash(newpass, opts.iterations, function() {
          err = arguments[0], hash = arguments[1];
          change = {
            $set: {
              passhash: hash
            }
          };
          users.update({
            name: username
          }, change);
          return cb(true);
        });
      }
    };
  };

  function checkPassword(username, pass, cb) {
    var e, er, res, user;
    e = null;
    er = null;
    res = false;
    delay(700, function() {
      if (e != null) {
        return cb(false);
      } else {
        return cb(res);
      }
    });
    users.findOne({
      name: username
    }, function() {
      e = arguments[0], user = arguments[1];
      if ((e == null) && (user != null)) {
        bcrypt.compare(pass, user.passhash, function() {
          return er = arguments[0], res = arguments[1], er;
        });
      } else {
        return res = false;
      }
    });
  };

  exports.opts = opts;

  exports.config = config;

  exports.add = add;

  exports.checkExists = checkExists;

  exports.resetPassword = resetPassword;

  exports.updatePassword = updatePassword;

  exports.checkPassword = checkPassword;

  exports.addNoEmail = addNoEmail;

  exports.users = users;

}).call(this);
